package com.yxm.sso.service.impl;

import java.util.List;

import javax.annotation.Resource;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.stereotype.Service;

import com.yxm.sso.context.AppContext;
import com.yxm.sso.context.GlobalSessions;
import com.yxm.sso.context.UrlPage;
import com.yxm.sso.domain.Application;
import com.yxm.sso.domain.Person;
import com.yxm.sso.domain.vo.UserVo;
import com.yxm.sso.mapper.PersonMapper;
import com.yxm.sso.service.ApplicationService;
import com.yxm.sso.service.PersonService;
import com.yxm.sso.util.SpringContextUtils;
import com.yxm.sso.util.StringUtils;
import com.yxm.sso.util.TokenUtils;
import com.yxm.sso.util.domain.DealResult;
import com.yxm.sso.util.domain.DealStatus;
import com.yxm.sso.util.service.RedisServiceImpl;

@Service
public class PersonServiceImpl implements PersonService {
	Log logger = LogFactory.getLog(PersonServiceImpl.class);

	@Resource
	PersonMapper personMapper;

	@Override
	public int addRecord(Person p) {
		return personMapper.addRecord(p);
	}

	@Override
	public int saveOrUpdate(Person p) {
		return personMapper.saveOrUpdate(p);
	}

	@Override
	public Person getDetail(String id) {
		return personMapper.getDetail(id);
	}

	@Override
	public void deleteRecord(String id) {
		personMapper.deleteRecord(id);
	}

	@Override
	public Person queryBySql(String sql) {
		return personMapper.queryBySql(sql);
	}

	@Override
	public List<Person> findListBySql(String sql) {
		return personMapper.findListBySql(sql);
	}

	@Override
	public List<Person> listAll() {
		return personMapper.listAll();
	}

	/**
	 * <p>
	 * 说明:通过token和backUrl获取用户信息
	 * </p>
	 * 
	 * @author:姚旭民
	 * @date:2017-7-17 下午5:02:24
	 */
	public DealResult getInfoByToken(HttpSession session,
			HttpServletRequest request, String token) {
		DealResult result = null;
		// 【1】检查是否为null
		if (StringUtils.isNotBlank(token)) {
			// 【2】通过token获取redis里面的sessionId
			// String sessionId = TokenUtils.getSessionId(token);
			// 【3】通过sessionId获取线程池里面保存的session
			// HttpSession tempSession = GlobalSessions.getSession(sessionId);
			// 【4】通过session对象获取里面的用户信息对象
			// result = new DealResult();
			// result.setCode(DealStatus.SUCCESS.getCode());
			// result.setMsg(DealStatus.SUCCESS.getMsg());
			// System.out
			// .println("tempSession.getAttribute(AppContext.KEY_SESSION_USER):"
			// + tempSession
			// .getAttribute(AppContext.KEY_SESSION_USER));
			// UserVo userVo = (UserVo) tempSession
			// .getAttribute(AppContext.KEY_SESSION_USER);
			// result.setData(((UserVo) tempSession
			// .getAttribute(AppContext.KEY_SESSION_USER)).getPerson());
			// System.out.println("ceshi");
		}
		return result;
	}

	/**
	 * <p>
	 * 说明:验证登陆者信息
	 * </p>
	 * 
	 * @author:姚旭民
	 * @date:2017-7-13 下午4:09:16
	 */
	@Override
	public DealResult verifyLogin(HttpSession session,
			HttpServletRequest request, String username, String url) {
		DealResult result = null;
		if (StringUtils.isNotBlank(username)) {
			String token;
			result = new DealResult();
			Person person = new Person();
			person.setUsername(username);
			// 【1】不存在token，查询账号，验证是否存在
			Person tempPerson = personMapper.verifyPerson(person);
			// 【2】如果查询得到账号，那么证明存在，为其生成token
			if (tempPerson != null) {// 账号验证正确，生成token，然后根据返回地址带上token重定向
				if (!verifyExistToken(session)) {
					tempPerson.setPassword(null);
					// 【3】通过查询得到的用户资料来差查对应的application对象，然后返回对应的token消息
					ApplicationService applicationService = (ApplicationService) SpringContextUtils
							.getBean(ApplicationService.class);
					// 通过applicationId 来获取信息
					Application tempApp = applicationService
							.selectByPrimaryKey(tempPerson.getApplicationid());
					// 【4】生成加密过后的token
 					token = TokenUtils.encodeToken(tempPerson.getId(), tempPerson.getUsername(), "Person");
					String tokenDecode = TokenUtils.decodeOfString(token); 
					// 【5】设置处理结果
					UserVo userVo = new UserVo(token, session.getId(),
							tempPerson);// token包装类型
					// 如果是验证通过了的，直接改写url
					url = "redirect:" + tempApp.getAccepttokenurl() + "?token="
							+ token;// 请求重定向到发起请求的位置
					//将数据缓存到redis里面
					if(RedisServiceImpl.saveInfoCache(tempPerson, tempPerson.getId()+"")) {
						System.out.println("对象保存到redis里面成功");
					}
					result.setToken(token);
					result.setTokenInfo(DealStatus.SUCCESS.getCode(),
							DealStatus.SUCCESS.getMsg(), url, true);
				} else {// 已经生成了token过的
					token = ((UserVo) session
							.getAttribute(AppContext.KEY_SESSION_USER))
							.getToken();
					UserVo userVo = new UserVo(token, tempPerson);// token包装类型
					url = "redirect:" + url + "?" + token;// 请求重定向到发起请求的位置
					System.out.println("url的内容为：" + url);
					result.setTokenInfo(DealStatus.SUCCESS.getCode(),
							DealStatus.SUCCESS.getMsg(), url, true);
					result.setToken(token);
				}
			} else {// 账号信息验证失败，重新回到登录页面

			}
		} else {// 账号信息验证失败，重新回到登录页面
			result.setTokenInfo(DealStatus.ERROR.getCode(),
					DealStatus.ERROR.getMsg(), url, false);
			result.setUrl(UrlPage.PAGE_LOGIN);
			logger.info("PersonServiceImpl类的verifyLogin方法出错");
		}
		return result;
	}

	/**
	 * <p>
	 * 说明:验证token，如果没有就生成，存在就返回特定结果
	 * </p>
	 * 
	 * @author:姚旭民
	 * @date:2017-7-13 下午4:16:47
	 * 
	 * @return 返回一个包含对象，里面有处理结果还有重定向的url
	 */
	public DealResult verifyToken(HttpSession session,
			HttpServletRequest request, String token) {
		DealResult result = new DealResult();
		// 【1】验证token的真实性
		if (TokenUtils.verifyToken(token, session.getId())) {
			ApplicationService applicationService = (ApplicationService) SpringContextUtils
					.getBean("applicationService");
			StringBuilder sql = new StringBuilder();
			sql.append("SELECT * FROM " + AppContext.TABLE_APPLICAITON
					+ "WHERE url = " + request.getRequestURI());
//			url = "redirect:" + url + "?" + token;// 请求重定向到发起请求的位置
//			result.setTokenInfo(DealStatus.SUCCESS.getCode(),
//					DealStatus.SUCCESS.getMsg(), url, true);
			// 【2】token真实存在，后面这里应该有一个验证的列表，除了在这个域名内的能进行更换，其余情况都不能更换userVo信息，待续

		} else {
			 result.setTokenInfo(DealStatus.ERROR.getCode(),
			 DealStatus.ERROR.getMsg(), UrlPage.PAGE_LOGIN, false);
			 result.setUrl(UrlPage.PAGE_LOGIN);
			 // url才是真实控制器要跳转的页面
		}
		return result;
	}

	/*
	 * <p>Description:验证当前线程里面是否存在了有效的token</p>
	 * 
	 * @author:姚旭民
	 * 
	 * @data:2017-7-18 上午9:38:31
	 * 
	 * @param:HttpSession session
	 * 
	 * @return:存在有效token返回true，其余均为false
	 */
	public boolean verifyExistToken(HttpSession session) {
		boolean flag = false;
		// 【1】从session里面获取得到保存的UserVo对象
		UserVo userVo = (UserVo) session
				.getAttribute(AppContext.KEY_SESSION_USER);
		if (userVo != null && userVo.getToken() != null) {// 检查是否存在，如果存在，再进行下一步检验
			// 【2】既然存在，就检查一下这个token是否是有效token
			flag = TokenUtils.verifyToken(userVo.getToken(), session.getId());
		}
		return flag;
	}

	/*
	 * <p>Description:用户做出登出处理的时候</p>
	 * 
	 * @author:姚旭民
	 * 
	 * @data:2017-7-20 下午4:38:24
	 */
	@Override
	public DealResult loginOut(HttpSession session, HttpServletRequest request,
			String token) {
		DealResult result = null;
		try {
			// tokenUtils里面包含了线程池对于session的处理，虽然现在这样不合理，后面要考虑要怎么切割好
			// 只要不报错，就是删除成功了
			TokenUtils.delToken(token);
			// 打包成功处理结果
			result = DealResult.defaultSuccess();
		} catch (Exception e) {
			// 打包时报处理结果
			result = DealResult.defaultError();
			logger.info("PersonServiceImpl类的loginOut方法出错");
		}
		return result;
	}
}
